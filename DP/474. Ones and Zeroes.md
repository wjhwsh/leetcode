[474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)  
Recursive + memo
```
class Solution {
    var memo = [[[Int]]]()
    func findMaxForm(_ strs: [String], _ m: Int, _ n: Int) -> Int {
        memo = Array(repeating: Array(repeating: Array(repeating: -1, count: n+1), count: m+1), count: strs.count)
        return calculate(strs, 0, m, n)
    }
    
    func calculate(_ strs: [String], _ index: Int, _ m: Int, _ n: Int) -> Int {
        if index == strs.count {
            return 0
        }
        if memo[index][m][n] != -1 {return memo[index][m][n]}
        let one = strs[index].compactMap {$0 == "1" ? 1: 0}.reduce(0, +)
        let zero = strs[index].count - one
        if m - zero >= 0 && n - one >= 0 {
            
            memo[index][m][n] = max(calculate(strs, index+1, m, n), 1 + calculate(strs, index+1, m-zero, n-one))
        } else {
            memo[index][m][n] = calculate(strs, index+1, m, n)
        }
        return memo[index][m][n]
    }
}
```

DP
```
class Solution {
    func findMaxForm(_ strs: [String], _ m: Int, _ n: Int) -> Int {
        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)
        for str in strs {
            let ones = str.compactMap {$0.wholeNumberValue}.reduce(0, +)
            let zeros = str.count - ones
            for i in stride(from: m, through: zeros, by: -1) {
                for j in stride(from: n, through: ones, by: -1) {
                    dp[i][j] = max(dp[i][j], 1 + dp[i-zeros][j-ones])
                }
            }
        }
        return dp[m][n]
    }
}

```
